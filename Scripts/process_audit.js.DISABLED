#!/usr/bin/env node
/**
 * ãƒ—ãƒ­ã‚»ã‚¹ç›£æŸ»ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 * child_processä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã‚¾ãƒ³ãƒ“ãƒ—ãƒ­ã‚»ã‚¹ç™ºç”ŸåŸå› ã®èª¿æŸ»
 */

const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');
const { promisify } = require('util');

// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ã‚’ãƒ­ãƒ¼ãƒ‰
require('./nodejs_error_handler.js');

const execAsync = promisify(exec);

// è¨­å®š
const CONFIG = {
    PROJECT_DIR: path.join(__dirname, '..'),
    LOG_FILE: path.join(__dirname, '..', 'Logs', 'process_audit.log'),
    ANALYSIS_FILE: path.join(__dirname, '..', 'Logs', 'process_analysis.json')
};

// ãƒ­ã‚°å‡ºåŠ›é–¢æ•°
function log(level, message, data = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
        timestamp,
        level,
        message,
        pid: process.pid,
        ...data
    };

    const logLine = `[${timestamp}] [${level}] ${message} ${JSON.stringify(data)}\n`;

    // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ã‚°
    fs.appendFileSync(CONFIG.LOG_FILE, logLine);

    // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
    console.log(logLine.trim());
}

// ç¾åœ¨ã®ãƒ—ãƒ­ã‚»ã‚¹çŠ¶æ³åˆ†æ
async function analyzeCurrentProcesses() {
    log('INFO', 'Starting process analysis');

    const analysis = {
        timestamp: new Date().toISOString(),
        totalProcesses: 0,
        zombieProcesses: [],
        claudeProcesses: [],
        mcpProcesses: [],
        nodeProcesses: [],
        systemInfo: {}
    };

    try {
        // ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±å–å¾—
        const meminfo = await execAsync('free -m');
        const cpuinfo = await execAsync('nproc');
        const uptime = await execAsync('uptime');

        analysis.systemInfo = {
            memory: meminfo.stdout.trim(),
            cpuCores: parseInt(cpuinfo.stdout.trim()),
            uptime: uptime.stdout.trim()
        };

        // ãƒ—ãƒ­ã‚»ã‚¹ä¸€è¦§å–å¾—
        const psResult = await execAsync('ps aux --no-headers');
        const processes = psResult.stdout.trim().split('\n');

        analysis.totalProcesses = processes.length;

        // ãƒ—ãƒ­ã‚»ã‚¹åˆ†é¡
        for (const processLine of processes) {
            const fields = processLine.trim().split(/\s+/);
            if (fields.length < 11) continue;

            const processInfo = {
                user: fields[0],
                pid: parseInt(fields[1]),
                cpu: parseFloat(fields[2]),
                mem: parseFloat(fields[3]),
                stat: fields[7],
                command: fields.slice(10).join(' ')
            };

            // ã‚¾ãƒ³ãƒ“ãƒ—ãƒ­ã‚»ã‚¹æ¤œå‡º
            if (processInfo.stat.includes('Z') || processInfo.command.includes('<defunct>')) {
                analysis.zombieProcesses.push(processInfo);
            }

            // Claudeé–¢é€£ãƒ—ãƒ­ã‚»ã‚¹
            if (processInfo.command.includes('claude')) {
                analysis.claudeProcesses.push(processInfo);
            }

            // MCPé–¢é€£ãƒ—ãƒ­ã‚»ã‚¹
            if (processInfo.command.includes('mcp') ||
                processInfo.command.includes('context7') ||
                processInfo.command.includes('fetch') ||
                processInfo.command.includes('gemini-cli') ||
                processInfo.command.includes('jupyter')) {
                analysis.mcpProcesses.push(processInfo);
            }

            // Node.jsé–¢é€£ãƒ—ãƒ­ã‚»ã‚¹
            if (processInfo.command.includes('node') && !processInfo.command.includes('claude')) {
                analysis.nodeProcesses.push(processInfo);
            }
        }

        log('INFO', 'Process analysis completed', {
            totalProcesses: analysis.totalProcesses,
            zombieCount: analysis.zombieProcesses.length,
            claudeCount: analysis.claudeProcesses.length,
            mcpCount: analysis.mcpProcesses.length
        });

        return analysis;

    } catch (error) {
        log('ERROR', 'Process analysis failed', { error: error.message });
        throw error;
    }
}

// ã‚¾ãƒ³ãƒ“ãƒ—ãƒ­ã‚»ã‚¹è©³ç´°èª¿æŸ»
async function analyzeZombieProcesses(analysis) {
    log('INFO', 'Analyzing zombie processes');

    const zombieAnalysis = {
        patterns: {},
        parentProcesses: {},
        recommendations: []
    };

    for (const zombie of analysis.zombieProcesses) {
        try {
            // è¦ªãƒ—ãƒ­ã‚»ã‚¹æƒ…å ±å–å¾—
            const parentInfo = await execAsync(`ps -o pid,ppid,command --no-headers -p ${zombie.pid} 2>/dev/null || echo "Process not found"`);

            if (!parentInfo.stdout.includes('Process not found')) {
                const parentFields = parentInfo.stdout.trim().split(/\s+/);
                const ppid = parseInt(parentFields[1]);

                // è¦ªãƒ—ãƒ­ã‚»ã‚¹ã®è©³ç´°å–å¾—
                const parentDetail = await execAsync(`ps -o pid,command --no-headers -p ${ppid} 2>/dev/null || echo "Parent not found"`);

                if (!parentDetail.stdout.includes('Parent not found')) {
                    const parentCommand = parentDetail.stdout.trim().split(/\s+/).slice(1).join(' ');

                    zombieAnalysis.parentProcesses[ppid] = {
                        pid: ppid,
                        command: parentCommand,
                        zombieChildren: (zombieAnalysis.parentProcesses[ppid]?.zombieChildren || 0) + 1
                    };

                    // ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
                    if (parentCommand.includes('claude')) {
                        zombieAnalysis.patterns['claude'] = (zombieAnalysis.patterns['claude'] || 0) + 1;
                    }
                    if (parentCommand.includes('npm')) {
                        zombieAnalysis.patterns['npm'] = (zombieAnalysis.patterns['npm'] || 0) + 1;
                    }
                    if (parentCommand.includes('node')) {
                        zombieAnalysis.patterns['node'] = (zombieAnalysis.patterns['node'] || 0) + 1;
                    }
                }
            }
        } catch (error) {
            log('WARNING', 'Failed to analyze zombie process', {
                pid: zombie.pid,
                error: error.message
            });
        }
    }

    // æ¨å¥¨äº‹é …ç”Ÿæˆ
    if (zombieAnalysis.patterns['claude'] > 0) {
        zombieAnalysis.recommendations.push({
            issue: 'Claude processes creating zombie children',
            recommendation: 'Claude sub-agent Task tool may not be properly cleaning up child processes',
            priority: 'HIGH'
        });
    }

    if (zombieAnalysis.patterns['npm'] > 0) {
        zombieAnalysis.recommendations.push({
            issue: 'npm processes creating zombie children',
            recommendation: 'MCP server startup scripts may have improper process handling',
            priority: 'MEDIUM'
        });
    }

    Object.keys(zombieAnalysis.parentProcesses).forEach(ppid => {
        const parent = zombieAnalysis.parentProcesses[ppid];
        if (parent.zombieChildren > 2) {
            zombieAnalysis.recommendations.push({
                issue: `Process ${ppid} has ${parent.zombieChildren} zombie children`,
                recommendation: `Review process management in: ${parent.command}`,
                priority: 'HIGH'
            });
        }
    });

    log('INFO', 'Zombie process analysis completed', {
        patterns: zombieAnalysis.patterns,
        parentProcessCount: Object.keys(zombieAnalysis.parentProcesses).length,
        recommendationCount: zombieAnalysis.recommendations.length
    });

    return zombieAnalysis;
}

// child_processä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³èª¿æŸ»
async function auditChildProcessUsage() {
    log('INFO', 'Auditing child_process usage patterns');

    const auditResults = {
        bestPractices: [],
        violations: [],
        recommendations: []
    };

    // ä¸€èˆ¬çš„ãªchild_processä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç¢ºèª
    const commonPatterns = [
        {
            name: 'Event handler cleanup',
            check: 'Proper exit/close event handling',
            recommendation: 'Always add exit and close event listeners to child processes'
        },
        {
            name: 'Error handling',
            check: 'Error event handling',
            recommendation: 'Add error event listeners to prevent uncaught exceptions'
        },
        {
            name: 'Process timeout',
            check: 'Timeout management',
            recommendation: 'Implement timeouts to prevent hanging processes'
        },
        {
            name: 'Signal handling',
            check: 'Proper signal handling on parent exit',
            recommendation: 'Handle SIGTERM/SIGINT to gracefully shutdown child processes'
        }
    ];

    auditResults.bestPractices = commonPatterns;

    // å®Ÿéš›ã®Node.jsãƒ—ãƒ­ã‚»ã‚¹ã§ã®child_processç›£è¦–ãƒ†ã‚¹ãƒˆ
    try {
        const testProcess = spawn('echo', ['test'], { stdio: 'pipe' });
        let exitHandled = false;
        let closeHandled = false;

        testProcess.on('exit', (code) => {
            exitHandled = true;
            log('INFO', 'Test process exit event', { code });
        });

        testProcess.on('close', (code) => {
            closeHandled = true;
            log('INFO', 'Test process close event', { code });
        });

        testProcess.on('error', (error) => {
            log('ERROR', 'Test process error', { error: error.message });
        });

        // ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†ã‚’å¾…ã¤
        await new Promise((resolve) => {
            testProcess.on('close', resolve);
        });

        // ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ãƒã‚§ãƒƒã‚¯
        if (exitHandled && closeHandled) {
            auditResults.recommendations.push({
                issue: 'Good practice demonstrated',
                recommendation: 'Both exit and close events were properly handled',
                priority: 'INFO'
            });
        } else {
            auditResults.violations.push({
                issue: 'Missing event handlers',
                recommendation: 'Ensure both exit and close events are handled',
                priority: 'HIGH'
            });
        }

    } catch (error) {
        log('ERROR', 'Child process audit test failed', { error: error.message });
        auditResults.violations.push({
            issue: 'Child process test failed',
            recommendation: 'Unable to verify child process handling patterns',
            priority: 'MEDIUM'
        });
    }

    return auditResults;
}

// ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
function generateReport(analysis, zombieAnalysis, auditResults) {
    const report = {
        timestamp: new Date().toISOString(),
        summary: {
            totalProcesses: analysis.totalProcesses,
            zombieProcesses: analysis.zombieProcesses.length,
            claudeProcesses: analysis.claudeProcesses.length,
            mcpProcesses: analysis.mcpProcesses.length,
            systemHealth: analysis.zombieProcesses.length < 5 ? 'GOOD' : 'POOR'
        },
        detailedAnalysis: {
            processAnalysis: analysis,
            zombieAnalysis,
            auditResults
        },
        recommendations: [
            ...zombieAnalysis.recommendations,
            ...auditResults.recommendations
        ].sort((a, b) => {
            const priority = { HIGH: 3, MEDIUM: 2, LOW: 1, INFO: 0 };
            return priority[b.priority] - priority[a.priority];
        })
    };

    // JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    fs.writeFileSync(CONFIG.ANALYSIS_FILE, JSON.stringify(report, null, 2));

    log('INFO', 'Process audit report generated', {
        file: CONFIG.ANALYSIS_FILE,
        recommendationCount: report.recommendations.length
    });

    return report;
}

// ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°
async function main() {
    log('INFO', 'Process audit started', {
        nodeVersion: process.version,
        platform: process.platform,
        pid: process.pid
    });

    try {
        // 1. ç¾åœ¨ã®ãƒ—ãƒ­ã‚»ã‚¹çŠ¶æ³åˆ†æ
        const analysis = await analyzeCurrentProcesses();

        // 2. ã‚¾ãƒ³ãƒ“ãƒ—ãƒ­ã‚»ã‚¹è©³ç´°èª¿æŸ»
        const zombieAnalysis = await analyzeZombieProcesses(analysis);

        // 3. child_processä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ç›£æŸ»
        const auditResults = await auditChildProcessUsage();

        // 4. ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
        const report = generateReport(analysis, zombieAnalysis, auditResults);

        // çµæœè¡¨ç¤º
        console.log('\nğŸ” Process Audit Report');
        console.log('======================');
        console.log(`ğŸ“Š Total Processes: ${report.summary.totalProcesses}`);
        console.log(`ğŸ§Ÿ Zombie Processes: ${report.summary.zombieProcesses}`);
        console.log(`ğŸ¤– Claude Processes: ${report.summary.claudeProcesses}`);
        console.log(`ğŸ”— MCP Processes: ${report.summary.mcpProcesses}`);
        console.log(`ğŸ’š System Health: ${report.summary.systemHealth}`);
        console.log(`ğŸ“ Recommendations: ${report.recommendations.length}`);

        if (report.recommendations.length > 0) {
            console.log('\nğŸš¨ Top Recommendations:');
            report.recommendations.slice(0, 3).forEach((rec, index) => {
                console.log(`${index + 1}. [${rec.priority}] ${rec.issue}`);
                console.log(`   â†’ ${rec.recommendation}`);
            });
        }

        console.log(`\nğŸ“„ Full report: ${CONFIG.ANALYSIS_FILE}`);
        console.log(`ğŸ“ Detailed log: ${CONFIG.LOG_FILE}`);

    } catch (error) {
        log('ERROR', 'Process audit failed', { error: error.message });
        console.error(`âŒ Process audit failed: ${error.message}`);
        process.exit(1);
    }
}

// å®Ÿè¡Œ
if (require.main === module) {
    main().catch(error => {
        log('ERROR', 'Main execution failed', { error: error.message });
        process.exit(1);
    });
}

module.exports = {
    analyzeCurrentProcesses,
    analyzeZombieProcesses,
    auditChildProcessUsage,
    generateReport
};
