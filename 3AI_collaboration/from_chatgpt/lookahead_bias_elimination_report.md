# Look-ahead Bias 根絶分析レポート

## 1. 前回の危険コード要点
1. **`bar['close']` 直接参照**  
   - エントリー・エグジットを当該バーの終値で行っており、現実のストリーミングでは不可。  
2. **未来データアクセス**  
   - `iloc[:i+1]` を使って「現在バーを含む」履歴を与えていた。  
3. **キャッシュ副作用**  
   - `@lru_cache` 等がインスタンス間で結果を共有し、異なるデータを誤用。  

## 2. 今回の修正内容
1. **bar['close'] 厳格排除**  
   - エントリー／エグジット価格は必ず次バーの始値 `next_open` のみを使用。  
2. **履歴スライスを `iloc[:i]` に統一**  
   - 現在バーを一切含まない形でシグナル生成・決済判定。  
3. **キャッシュ完全排除**  
   - 状態依存キャッシュは廃止し、純粋関数型呼び出しのみ。  
4. **WFA 各フォールド独立**  
   - 学習期間とテスト期間のデータは完全分離し、いかなる未来データも流用しない。  

## 3. 修正の根拠
- **Look-ahead bias**: 終値や当該バーの情報を使うと、実市場で未知の情報をバックテストに含めてしまう。  
- **リアルタイム互換**: エントリー／エグジットは常に「次バー始値」で行うことで、巡回遅延を厳密に再現。  
- **純粋関数設計**: 履歴のみを渡すことで副作用を排し、検証可能性を高める。  

## 4. 学習ポイント
1. **未来データの絶対遮断**: 毎回「何が現実に知れるか」を厳密に定義し実装。  
2. **履歴スライス誤用に要注意**: `i+1`／`i` の差で一瞬の未来を含むか否かが決まる。  
3. **キャッシュは裏切る**: 状態依存キャッシュはバックテストに混乱を招く。  
4. **リアルタイム互換性優先**: バックテストコードはライブ環境相当の制約で動くべき。  

## 5. 検証方法
1. **print デバッグ**  
   - 各フォールドで `next_open` のみ使われているかログ出力確認。  
2. **履歴長チェック**  
   - `generate_signal(...history.iloc[:i])` の履歴長が `i` と一致するか。  
3. **PF 比較テスト**  
   - 修正前後で大幅変動するシナリオがあれば過去にバイアスがあった証拠。  
4. **ライブデモ**  
   - 実際のストリーミングティックを流し、リアルタイム動作と同一結果となるか照合。  
